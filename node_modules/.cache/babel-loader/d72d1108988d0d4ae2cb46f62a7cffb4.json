{"ast":null,"code":"function _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n/*! tether 2.0.0 */\n!function (t, e) {\n  \"object\" == (typeof exports === \"undefined\" ? \"undefined\" : _typeof(exports)) && \"undefined\" != typeof module ? module.exports = e() : \"function\" == typeof define && define.amd ? define(e) : (t = \"undefined\" != typeof globalThis ? globalThis : t || self).Tether = e();\n}(this, function () {\n  \"use strict\";\n\n  function t(e, o) {\n    return (t = Object.setPrototypeOf || function (t, e) {\n      return t.__proto__ = e, t;\n    })(e, o);\n  }\n\n  function e(t) {\n    if (void 0 === t) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n    return t;\n  }\n\n  function o(t) {\n    return \"string\" == typeof t;\n  }\n\n  function i(t) {\n    return void 0 === t;\n  }\n\n  function n(t, e) {\n    e.split(\" \").forEach(function (e) {\n      e.trim() && t.classList.add(e);\n    });\n  }\n\n  function s(t, e, o) {\n    return void 0 === t && (t = \"\"), i(e) || i(e[t]) ? o ? o + \"-\" + t : t : !1 === e[t] ? \"\" : e[t];\n  }\n\n  function r(t, e) {\n    e.split(\" \").forEach(function (e) {\n      e.trim() && t.classList.remove(e);\n    });\n  }\n\n  function a(t, e, o) {\n    o.forEach(function (o) {\n      -1 === e.indexOf(o) && t.classList.contains(o) && r(t, o);\n    }), e.forEach(function (e) {\n      t.classList.contains(e) || n(t, e);\n    });\n  }\n\n  var h = [];\n\n  function l(t) {\n    h.push(t);\n  }\n\n  function f() {\n    for (var t; t = h.pop();) {\n      t();\n    }\n  }\n\n  var p = null;\n\n  function d(t) {\n    void 0 === t && (t = {});\n    var e = [];\n    return Array.prototype.push.apply(e, arguments), e.slice(1).forEach(function (e) {\n      if (e) for (var o in e) {\n        ({}).hasOwnProperty.call(e, o) && (t[o] = e[o]);\n      }\n    }), t;\n  }\n\n  function c() {\n    if (p) return p;\n    var t = document.createElement(\"div\");\n    t.style.width = \"100%\", t.style.height = \"200px\";\n    var e = document.createElement(\"div\");\n    d(e.style, {\n      position: \"absolute\",\n      top: 0,\n      left: 0,\n      pointerEvents: \"none\",\n      visibility: \"hidden\",\n      width: \"200px\",\n      height: \"150px\",\n      overflow: \"hidden\"\n    }), e.appendChild(t), document.body.appendChild(e);\n    var o = t.offsetWidth;\n    e.style.overflow = \"scroll\";\n    var i = t.offsetWidth;\n    o === i && (i = e.clientWidth), document.body.removeChild(e);\n    var n = o - i;\n    return p = {\n      width: n,\n      height: n\n    };\n  }\n\n  var u,\n      m = (u = 0, function () {\n    return ++u;\n  }),\n      g = {},\n      v = null;\n\n  function b(t, e) {\n    var o;\n    e === document ? (o = document, e = document.documentElement) : o = e.ownerDocument;\n\n    var n = o.documentElement,\n        s = w(e),\n        r = function (t) {\n      var e = v;\n      e && t.contains(e) || ((e = document.createElement(\"div\")).setAttribute(\"data-tether-id\", m()), d(e.style, {\n        top: 0,\n        left: 0,\n        position: \"absolute\"\n      }), t.appendChild(e), v = e);\n      var o = e.getAttribute(\"data-tether-id\");\n      i(g[o]) && (g[o] = w(e), l(function () {\n        delete g[o];\n      }));\n      return g[o];\n    }(t);\n\n    return s.top -= r.top, s.left -= r.left, i(s.width) && (s.width = document.body.scrollWidth - s.left - s.right), i(s.height) && (s.height = document.body.scrollHeight - s.top - s.bottom), s.top = s.top - n.clientTop, s.left = s.left - n.clientLeft, s.right = o.body.clientWidth - s.width - s.left, s.bottom = o.body.clientHeight - s.height - s.top, s;\n  }\n\n  function w(t) {\n    var e = t.getBoundingClientRect(),\n        o = {};\n\n    for (var i in e) {\n      o[i] = e[i];\n    }\n\n    try {\n      if (t.ownerDocument !== document) {\n        var n = t.ownerDocument.defaultView.frameElement;\n\n        if (n) {\n          var s = w(n);\n          o.top += s.top, o.bottom += s.top, o.left += s.left, o.right += s.left;\n        }\n      }\n    } catch (t) {}\n\n    return o;\n  }\n\n  var y = {\n    position: function position(t) {\n      var e = this,\n          o = t.top,\n          i = t.left,\n          n = this.cache(\"element-bounds\", function () {\n        return b(e.element);\n      }),\n          r = n.height,\n          h = n.width,\n          f = this.getTargetBounds(),\n          p = o + r,\n          d = i + h,\n          c = [];\n      o <= f.bottom && p >= f.top && [\"left\", \"right\"].forEach(function (t) {\n        var e = f[t];\n        e !== i && e !== d || c.push(t);\n      }), i <= f.right && d >= f.left && [\"top\", \"bottom\"].forEach(function (t) {\n        var e = f[t];\n        e !== o && e !== p || c.push(t);\n      });\n      var u = this.options,\n          m = u.classes,\n          g = u.classPrefix;\n      return this.all.push(s(\"abutted\", m, g)), [\"left\", \"top\", \"right\", \"bottom\"].forEach(function (t) {\n        e.all.push(s(\"abutted\", m, g) + \"-\" + t);\n      }), c.length && this.add.push(s(\"abutted\", m, g)), c.forEach(function (t) {\n        e.add.push(s(\"abutted\", m, g) + \"-\" + t);\n      }), l(function () {\n        !1 !== e.options.addTargetClasses && a(e.target, e.add, e.all), a(e.element, e.add, e.all);\n      }), !0;\n    }\n  },\n      E = [\"left\", \"top\", \"right\", \"bottom\"];\n\n  var O = {\n    position: function position(t) {\n      var e = this,\n          n = t.top,\n          r = t.left,\n          h = t.targetAttachment;\n      if (!this.options.constraints) return !0;\n      var f = this.cache(\"element-bounds\", function () {\n        return b(e.bodyElement, e.element);\n      }),\n          p = f.height,\n          c = f.width;\n\n      if (0 === c && 0 === p && !i(this.lastSize)) {\n        var u = this.lastSize;\n        c = u.width, p = u.height;\n      }\n\n      var m = this.cache(\"target-bounds\", function () {\n        return e.getTargetBounds();\n      }),\n          g = m.height,\n          v = m.width,\n          w = this.options,\n          y = w.classes,\n          O = w.classPrefix,\n          x = function (t, e, o) {\n        var i = [s(\"pinned\", t, e), s(\"out-of-bounds\", t, e)];\n        return o.forEach(function (t) {\n          var e = t.outOfBoundsClass,\n              o = t.pinnedClass;\n          e && i.push(e), o && i.push(o);\n        }), i.forEach(function (t) {\n          [\"left\", \"top\", \"right\", \"bottom\"].forEach(function (e) {\n            i.push(t + \"-\" + e);\n          });\n        }), i;\n      }(y, O, this.options.constraints),\n          C = [],\n          T = d({}, h),\n          P = d({}, this.attachment);\n\n      return this.options.constraints.forEach(function (t) {\n        var a,\n            l,\n            f = t.to,\n            d = t.attachment,\n            u = t.pin;\n\n        if (i(d) && (d = \"\"), d.indexOf(\" \") >= 0) {\n          var m = d.split(\" \");\n          l = m[0], a = m[1];\n        } else a = l = d;\n\n        var w = function (t, e, o) {\n          if (!o) return null;\n\n          if (\"scrollParent\" === o ? o = e.scrollParents[0] : \"window\" === o && (o = [pageXOffset, pageYOffset, innerWidth + pageXOffset, innerHeight + pageYOffset]), o === document && (o = o.documentElement), !i(o.nodeType)) {\n            var n = o,\n                s = b(t, o),\n                r = s,\n                a = getComputedStyle(o);\n\n            if (o = [r.left, r.top, s.width + r.left, s.height + r.top], n.ownerDocument !== document) {\n              var h = n.ownerDocument.defaultView;\n              o[0] += h.pageXOffset, o[1] += h.pageYOffset, o[2] += h.pageXOffset, o[3] += h.pageYOffset;\n            }\n\n            E.forEach(function (t, e) {\n              \"Top\" === (t = t[0].toUpperCase() + t.substr(1)) || \"Left\" === t ? o[e] += parseFloat(a[\"border\" + t + \"Width\"]) : o[e] -= parseFloat(a[\"border\" + t + \"Width\"]);\n            });\n          }\n\n          return o;\n        }(e.bodyElement, e, f);\n\n        \"target\" !== l && \"both\" !== l || (n < w[1] && \"top\" === T.top && (n += g, T.top = \"bottom\"), n + p > w[3] && \"bottom\" === T.top && (n -= g, T.top = \"top\")), \"together\" === l && (n = function (t, e, o, i, n, s) {\n          return \"top\" === t.top && (\"bottom\" === e.top && s < o[1] ? (s += n, t.top = \"bottom\", s += i, e.top = \"top\") : \"top\" === e.top && s + i > o[3] && s - (i - n) >= o[1] && (s -= i - n, t.top = \"bottom\", e.top = \"bottom\")), \"bottom\" === t.top && (\"top\" === e.top && s + i > o[3] ? (s -= n, t.top = \"top\", s -= i, e.top = \"bottom\") : \"bottom\" === e.top && s < o[1] && s + (2 * i - n) <= o[3] && (s += i - n, t.top = \"top\", e.top = \"top\")), \"middle\" === t.top && (s + i > o[3] && \"top\" === e.top ? (s -= i, e.top = \"bottom\") : s < o[1] && \"bottom\" === e.top && (s += i, e.top = \"top\")), s;\n        }(T, P, w, p, g, n)), \"target\" !== a && \"both\" !== a || (r < w[0] && \"left\" === T.left && (r += v, T.left = \"right\"), r + c > w[2] && \"right\" === T.left && (r -= v, T.left = \"left\")), \"together\" === a && (r = function (t, e, o, i, n, s) {\n          return s < o[0] && \"left\" === t.left ? \"right\" === e.left ? (s += n, t.left = \"right\", s += i, e.left = \"left\") : \"left\" === e.left && (s += n, t.left = \"right\", s -= i, e.left = \"right\") : s + i > o[2] && \"right\" === t.left ? \"left\" === e.left ? (s -= n, t.left = \"left\", s -= i, e.left = \"right\") : \"right\" === e.left && (s -= n, t.left = \"left\", s += i, e.left = \"left\") : \"center\" === t.left && (s + i > o[2] && \"left\" === e.left ? (s -= i, e.left = \"right\") : s < o[0] && \"right\" === e.left && (s += i, e.left = \"left\")), s;\n        }(T, P, w, c, v, r)), \"element\" !== l && \"both\" !== l || (n < w[1] && \"bottom\" === P.top && (n += p, P.top = \"top\"), n + p > w[3] && \"top\" === P.top && (n -= p, P.top = \"bottom\")), \"element\" !== a && \"both\" !== a || (r < w[0] && (\"right\" === P.left ? (r += c, P.left = \"left\") : \"center\" === P.left && (r += c / 2, P.left = \"left\")), r + c > w[2] && (\"left\" === P.left ? (r -= c, P.left = \"right\") : \"center\" === P.left && (r -= c / 2, P.left = \"right\"))), o(u) ? u = u.split(\",\").map(function (t) {\n          return t.trim();\n        }) : !0 === u && (u = [\"top\", \"left\", \"right\", \"bottom\"]);\n        var x,\n            A = [],\n            W = [];\n        (r = function (t, e, o, i, n, s) {\n          return t < e[0] && (i.indexOf(\"left\") >= 0 ? (t = e[0], n.push(\"left\")) : s.push(\"left\")), t + o > e[2] && (i.indexOf(\"right\") >= 0 ? (t = e[2] - o, n.push(\"right\")) : s.push(\"right\")), t;\n        }(r, w, c, u = u || [], A, W), n = function (t, e, o, i, n, s) {\n          return t < e[1] && (i.indexOf(\"top\") >= 0 ? (t = e[1], n.push(\"top\")) : s.push(\"top\")), t + o > e[3] && (i.indexOf(\"bottom\") >= 0 ? (t = e[3] - o, n.push(\"bottom\")) : s.push(\"bottom\")), t;\n        }(n, w, p, u, A, W), A.length) && (x = i(e.options.pinnedClass) ? s(\"pinned\", y, O) : e.options.pinnedClass, C.push(x), A.forEach(function (t) {\n          C.push(x + \"-\" + t);\n        }));\n        !function (t, e, o, n, r) {\n          var a;\n          t.length && (a = i(r) ? s(\"out-of-bounds\", o, n) : r, e.push(a), t.forEach(function (t) {\n            e.push(a + \"-\" + t);\n          }));\n        }(W, C, y, O, e.options.outOfBoundsClass), (A.indexOf(\"left\") >= 0 || A.indexOf(\"right\") >= 0) && (P.left = T.left = !1), (A.indexOf(\"top\") >= 0 || A.indexOf(\"bottom\") >= 0) && (P.top = T.top = !1), T.top === h.top && T.left === h.left && P.top === e.attachment.top && P.left === e.attachment.left || (e.updateAttachClasses(P, T), e.trigger(\"update\", {\n          attachment: P,\n          targetAttachment: T\n        }));\n      }), l(function () {\n        !1 !== e.options.addTargetClasses && a(e.target, C, x), a(e.element, C, x);\n      }), {\n        top: n,\n        left: r\n      };\n    }\n  },\n      x = {\n    position: function position(t) {\n      var e = t.top,\n          i = t.left;\n\n      if (this.options.shift) {\n        var n,\n            s,\n            r = this.options.shift;\n\n        if (\"function\" == typeof r && (r = r.call(this, {\n          top: e,\n          left: i\n        })), o(r)) {\n          (r = r.split(\" \"))[1] = r[1] || r[0];\n          var a = r;\n          n = a[0], s = a[1], n = parseFloat(n, 10), s = parseFloat(s, 10);\n        } else {\n          var h = [r.top, r.left];\n          n = h[0], s = h[1];\n        }\n\n        return {\n          top: e += n,\n          left: i += s\n        };\n      }\n    }\n  },\n      C = function () {\n    function t() {}\n\n    var e = t.prototype;\n    return e.on = function (t, e, o, n) {\n      return void 0 === n && (n = !1), i(this.bindings) && (this.bindings = {}), i(this.bindings[t]) && (this.bindings[t] = []), this.bindings[t].push({\n        handler: e,\n        ctx: o,\n        once: n\n      }), this;\n    }, e.once = function (t, e, o) {\n      return this.on(t, e, o, !0);\n    }, e.off = function (t, e) {\n      var o = this;\n      return i(this.bindings) || i(this.bindings[t]) || (i(e) ? delete this.bindings[t] : this.bindings[t].forEach(function (i, n) {\n        i.handler === e && o.bindings[t].splice(n, 1);\n      })), this;\n    }, e.trigger = function (t) {\n      for (var e = this, o = arguments.length, n = new Array(o > 1 ? o - 1 : 0), s = 1; s < o; s++) {\n        n[s - 1] = arguments[s];\n      }\n\n      return !i(this.bindings) && this.bindings[t] && this.bindings[t].forEach(function (o, i) {\n        var s = o.ctx,\n            r = o.handler,\n            a = o.once,\n            h = s || e;\n        r.apply(h, n), a && e.bindings[t].splice(i, 1);\n      }), this;\n    }, t;\n  }(),\n      T = {\n    center: \"center\",\n    left: \"right\",\n    right: \"left\"\n  },\n      P = {\n    middle: \"middle\",\n    top: \"bottom\",\n    bottom: \"top\"\n  },\n      A = {\n    top: 0,\n    left: 0,\n    middle: \"50%\",\n    center: \"50%\",\n    bottom: \"100%\",\n    right: \"100%\"\n  };\n\n  function W() {\n    for (var t = {\n      top: 0,\n      left: 0\n    }, e = arguments.length, i = new Array(e), n = 0; n < e; n++) {\n      i[n] = arguments[n];\n    }\n\n    return i.forEach(function (e) {\n      var i = e.top,\n          n = e.left;\n      o(i) && (i = parseFloat(i)), o(n) && (n = parseFloat(n)), t.top += i, t.left += n;\n    }), t;\n  }\n\n  function _(t) {\n    var e = t.left,\n        o = t.top;\n    return i(A[t.left]) || (e = A[t.left]), i(A[t.top]) || (o = A[t.top]), {\n      left: e,\n      top: o\n    };\n  }\n\n  function M(t, e) {\n    return o(t.left) && -1 !== t.left.indexOf(\"%\") && (t.left = parseFloat(t.left) / 100 * e.width), o(t.top) && -1 !== t.top.indexOf(\"%\") && (t.top = parseFloat(t.top) / 100 * e.height), t;\n  }\n\n  function z(t) {\n    var e = t.split(\" \");\n    return {\n      top: e[0],\n      left: e[1]\n    };\n  }\n\n  function F(t) {\n    return t.offsetParent || document.documentElement;\n  }\n\n  var L = {\n    modules: [O, y, x]\n  };\n\n  var Y,\n      S,\n      X,\n      H,\n      D = function () {\n    if (i(document)) return \"\";\n\n    for (var t = document.createElement(\"div\"), e = [\"transform\", \"WebkitTransform\", \"OTransform\", \"MozTransform\", \"msTransform\"], o = 0; o < e.length; ++o) {\n      var n = e[o];\n      if (void 0 !== t.style[n]) return n;\n    }\n  }(),\n      k = [],\n      B = function B() {\n    k.forEach(function (t) {\n      t.position(!1);\n    }), f();\n  };\n\n  function N() {\n    return performance.now();\n  }\n\n  Y = null, S = null, X = null, H = function t() {\n    if (!i(S) && S > 16) return S = Math.min(S - 16, 250), void (X = setTimeout(t, 250));\n    !i(Y) && N() - Y < 10 || (null != X && (clearTimeout(X), X = null), Y = N(), B(), S = N() - Y);\n  }, i(window) || i(window.addEventListener) || [\"resize\", \"scroll\", \"touchmove\"].forEach(function (t) {\n    window.addEventListener(t, H);\n  });\n\n  var R = function (h) {\n    var p, u;\n\n    function m(t) {\n      var o;\n      return (o = h.call(this) || this).position = o.position.bind(e(o)), k.push(e(o)), o.history = [], o.setOptions(t, !1), L.modules.forEach(function (t) {\n        i(t.initialize) || t.initialize.call(e(o));\n      }), o.position(), o;\n    }\n\n    u = h, (p = m).prototype = Object.create(u.prototype), p.prototype.constructor = p, t(p, u);\n    var g = m.prototype;\n    return g.setOptions = function (t, e) {\n      var n = this;\n      void 0 === e && (e = !0);\n      var s = {\n        offset: \"0 0\",\n        targetOffset: \"0 0\",\n        targetAttachment: \"auto auto\",\n        classPrefix: \"tether\",\n        bodyElement: document.body\n      };\n      this.options = d(s, t);\n      var r = this.options,\n          a = r.element,\n          h = r.target,\n          l = r.targetModifier,\n          f = r.bodyElement;\n      if (this.element = a, this.target = h, this.targetModifier = l, \"string\" == typeof f && (f = document.querySelector(f)), this.bodyElement = f, \"viewport\" === this.target ? (this.target = document.body, this.targetModifier = \"visible\") : \"scroll-handle\" === this.target && (this.target = document.body, this.targetModifier = \"scroll-handle\"), [\"element\", \"target\"].forEach(function (t) {\n        if (i(n[t])) throw new Error(\"Tether Error: Both element and target must be defined\");\n        i(n[t].jquery) ? o(n[t]) && (n[t] = document.querySelector(n[t])) : n[t] = n[t][0];\n      }), this._addClasses(), !this.options.attachment) throw new Error(\"Tether Error: You must provide an attachment\");\n      this.targetAttachment = z(this.options.targetAttachment), this.attachment = z(this.options.attachment), this.offset = z(this.options.offset), this.targetOffset = z(this.options.targetOffset), i(this.scrollParents) || this.disable(), \"scroll-handle\" === this.targetModifier ? this.scrollParents = [this.target] : this.scrollParents = function (t) {\n        var e = (getComputedStyle(t) || {}).position,\n            o = [];\n        if (\"fixed\" === e) return [t];\n\n        for (var n = t; (n = n.parentNode) && n && 1 === n.nodeType;) {\n          var s = void 0;\n\n          try {\n            s = getComputedStyle(n);\n          } catch (t) {}\n\n          if (i(s) || null === s) return o.push(n), o;\n          var r = s,\n              a = r.overflow,\n              h = r.overflowX,\n              l = r.overflowY;\n          /(auto|scroll|overlay)/.test(a + l + h) && (\"absolute\" !== e || [\"relative\", \"absolute\", \"fixed\"].indexOf(s.position) >= 0) && o.push(n);\n        }\n\n        return o.push(t.ownerDocument.body), t.ownerDocument !== document && o.push(t.ownerDocument.defaultView), o;\n      }(this.target), !1 !== this.options.enabled && this.enable(e);\n    }, g.getTargetBounds = function () {\n      return i(this.targetModifier) ? b(this.bodyElement, this.target) : \"visible\" === this.targetModifier ? function (t, e) {\n        if (e === document.body) return {\n          top: pageYOffset,\n          left: pageXOffset,\n          height: innerHeight,\n          width: innerWidth\n        };\n        var o = b(t, e),\n            i = {\n          height: o.height,\n          width: o.width,\n          top: o.top,\n          left: o.left\n        };\n        return i.height = Math.min(i.height, o.height - (pageYOffset - o.top)), i.height = Math.min(i.height, o.height - (o.top + o.height - (pageYOffset + innerHeight))), i.height = Math.min(innerHeight, i.height), i.height -= 2, i.width = Math.min(i.width, o.width - (pageXOffset - o.left)), i.width = Math.min(i.width, o.width - (o.left + o.width - (pageXOffset + innerWidth))), i.width = Math.min(innerWidth, i.width), i.width -= 2, i.top < pageYOffset && (i.top = pageYOffset), i.left < pageXOffset && (i.left = pageXOffset), i;\n      }(this.bodyElement, this.target) : \"scroll-handle\" === this.targetModifier ? function (t, e) {\n        var o,\n            i = e.scrollTop,\n            n = e === document.body;\n        n ? (e = document.documentElement, o = {\n          left: pageXOffset,\n          top: pageYOffset,\n          height: innerHeight,\n          width: innerWidth\n        }) : o = b(t, e);\n        var s = getComputedStyle(e),\n            r = 0;\n        (e.scrollWidth > e.clientWidth || [s.overflow, s.overflowX].indexOf(\"scroll\") >= 0 || !n) && (r = 15);\n        var a = o.height - parseFloat(s.borderTopWidth) - parseFloat(s.borderBottomWidth) - r,\n            h = {\n          width: 15,\n          height: .975 * a * (a / e.scrollHeight),\n          left: o.left + o.width - parseFloat(s.borderLeftWidth) - 15\n        },\n            l = 0;\n        a < 408 && n && (l = -11e-5 * Math.pow(a, 2) - .00727 * a + 22.58), n || (h.height = Math.max(h.height, 24));\n        var f = i / (e.scrollHeight - a);\n        return h.top = f * (a - h.height - l) + o.top + parseFloat(s.borderTopWidth), n && (h.height = Math.max(h.height, 24)), h;\n      }(this.bodyElement, this.target) : void 0;\n    }, g.clearCache = function () {\n      this._cache = {};\n    }, g.cache = function (t, e) {\n      return i(this._cache) && (this._cache = {}), i(this._cache[t]) && (this._cache[t] = e.call(this)), this._cache[t];\n    }, g.enable = function (t) {\n      var e = this;\n      void 0 === t && (t = !0);\n      var o = this.options,\n          i = o.classes,\n          r = o.classPrefix;\n      !1 !== this.options.addTargetClasses && n(this.target, s(\"enabled\", i, r)), n(this.element, s(\"enabled\", i, r)), this.enabled = !0, this.scrollParents.forEach(function (t) {\n        t !== e.target.ownerDocument && t.addEventListener(\"scroll\", e.position);\n      }), t && this.position();\n    }, g.disable = function () {\n      var t = this,\n          e = this.options,\n          o = e.classes,\n          n = e.classPrefix;\n      r(this.target, s(\"enabled\", o, n)), r(this.element, s(\"enabled\", o, n)), this.enabled = !1, i(this.scrollParents) || this.scrollParents.forEach(function (e) {\n        e && e.removeEventListener && e.removeEventListener(\"scroll\", t.position);\n      });\n    }, g.destroy = function () {\n      var t,\n          e = this;\n      this.disable(), this._removeClasses(), k.forEach(function (t, o) {\n        t === e && k.splice(o, 1);\n      }), 0 === k.length && (t = this.bodyElement, v && t.removeChild(v), v = null);\n    }, g.updateAttachClasses = function (t, e) {\n      var o = this;\n      t = t || this.attachment, e = e || this.targetAttachment;\n      var n = this.options,\n          r = n.classes,\n          h = n.classPrefix;\n      !i(this._addAttachClasses) && this._addAttachClasses.length && this._addAttachClasses.splice(0, this._addAttachClasses.length), i(this._addAttachClasses) && (this._addAttachClasses = []), this.add = this._addAttachClasses, t.top && this.add.push(s(\"element-attached\", r, h) + \"-\" + t.top), t.left && this.add.push(s(\"element-attached\", r, h) + \"-\" + t.left), e.top && this.add.push(s(\"target-attached\", r, h) + \"-\" + e.top), e.left && this.add.push(s(\"target-attached\", r, h) + \"-\" + e.left), this.all = [], [\"left\", \"top\", \"bottom\", \"right\", \"middle\", \"center\"].forEach(function (t) {\n        o.all.push(s(\"element-attached\", r, h) + \"-\" + t), o.all.push(s(\"target-attached\", r, h) + \"-\" + t);\n      }), l(function () {\n        i(o._addAttachClasses) || (a(o.element, o._addAttachClasses, o.all), !1 !== o.options.addTargetClasses && a(o.target, o._addAttachClasses, o.all), delete o._addAttachClasses);\n      });\n    }, g.position = function (t) {\n      var e = this;\n\n      if (void 0 === t && (t = !0), this.enabled) {\n        this.clearCache();\n\n        var o = function (t, e) {\n          var o = t.left,\n              i = t.top;\n          return \"auto\" === o && (o = T[e.left]), \"auto\" === i && (i = P[e.top]), {\n            left: o,\n            top: i\n          };\n        }(this.targetAttachment, this.attachment);\n\n        this.updateAttachClasses(this.attachment, o);\n        var n = this.cache(\"element-bounds\", function () {\n          return b(e.bodyElement, e.element);\n        }),\n            s = n.width,\n            r = n.height;\n        if (0 !== s || 0 !== r || i(this.lastSize)) this.lastSize = {\n          width: s,\n          height: r\n        };else {\n          var a = this.lastSize;\n          s = a.width, r = a.height;\n        }\n        var h = this.cache(\"target-bounds\", function () {\n          return e.getTargetBounds();\n        }),\n            l = h,\n            p = M(_(this.attachment), {\n          width: s,\n          height: r\n        }),\n            d = M(_(o), l),\n            u = M(this.offset, {\n          width: s,\n          height: r\n        }),\n            m = M(this.targetOffset, l);\n        p = W(p, u), d = W(d, m);\n\n        for (var g = h.left + d.left - p.left, v = h.top + d.top - p.top, w = 0; w < L.modules.length; ++w) {\n          var y = L.modules[w].position.call(this, {\n            left: g,\n            top: v,\n            targetAttachment: o,\n            targetPos: h,\n            elementPos: n,\n            offset: p,\n            targetOffset: d,\n            manualOffset: u,\n            manualTargetOffset: m,\n            scrollbarSize: E,\n            attachment: this.attachment\n          });\n          if (!1 === y) return !1;\n          i(y) || \"object\" != _typeof(y) || (v = y.top, g = y.left);\n        }\n\n        var E,\n            O = {\n          page: {\n            top: v,\n            left: g\n          },\n          viewport: {\n            top: v - pageYOffset,\n            bottom: pageYOffset - v - r + innerHeight,\n            left: g - pageXOffset,\n            right: pageXOffset - g - s + innerWidth\n          }\n        },\n            x = this.target.ownerDocument,\n            C = x.defaultView;\n\n        if (C.innerHeight > x.documentElement.clientHeight && (E = this.cache(\"scrollbar-size\", c), O.viewport.bottom -= E.height), C.innerWidth > x.documentElement.clientWidth && (E = this.cache(\"scrollbar-size\", c), O.viewport.right -= E.width), -1 !== [\"\", \"static\"].indexOf(x.body.style.position) && -1 !== [\"\", \"static\"].indexOf(x.body.parentElement.style.position) || (O.page.bottom = x.body.scrollHeight - v - r, O.page.right = x.body.scrollWidth - g - s), !i(this.options.optimizations) && !1 !== this.options.optimizations.moveElement && i(this.targetModifier)) {\n          var A = this.cache(\"target-offsetparent\", function () {\n            return F(e.target);\n          }),\n              z = this.cache(\"target-offsetparent-bounds\", function () {\n            return b(e.bodyElement, A);\n          }),\n              Y = getComputedStyle(A),\n              S = z,\n              X = {};\n\n          if ([\"Top\", \"Left\", \"Bottom\", \"Right\"].forEach(function (t) {\n            X[t.toLowerCase()] = parseFloat(Y[\"border\" + t + \"Width\"]);\n          }), z.right = x.body.scrollWidth - z.left - S.width + X.right, z.bottom = x.body.scrollHeight - z.top - S.height + X.bottom, O.page.top >= z.top + X.top && O.page.bottom >= z.bottom && O.page.left >= z.left + X.left && O.page.right >= z.right) {\n            var H = A.scrollLeft,\n                D = A.scrollTop;\n            O.offset = {\n              top: O.page.top - z.top + D - X.top,\n              left: O.page.left - z.left + H - X.left\n            };\n          }\n        }\n\n        return this.move(O), this.history.unshift(O), this.history.length > 3 && this.history.pop(), t && f(), !0;\n      }\n    }, g.move = function (t) {\n      var e = this;\n\n      if (!i(this.element.parentNode)) {\n        var o,\n            n,\n            s,\n            r = {};\n\n        for (var a in t) {\n          for (var h in r[a] = {}, t[a]) {\n            for (var f = !1, p = 0; p < this.history.length; ++p) {\n              var c = this.history[p];\n\n              if (!(i(c[a]) || (o = c[a][h], n = t[a][h], s = void 0, void 0 === s && (s = 1), o + s >= n && n >= o - s))) {\n                f = !0;\n                break;\n              }\n            }\n\n            f || (r[a][h] = !0);\n          }\n        }\n\n        var u = {\n          top: \"\",\n          left: \"\",\n          right: \"\",\n          bottom: \"\"\n        },\n            m = function m(t, o) {\n          var n, s;\n          !1 !== (!i(e.options.optimizations) ? e.options.optimizations.gpu : null) ? (t.top ? (u.top = 0, n = o.top) : (u.bottom = 0, n = -o.bottom), t.left ? (u.left = 0, s = o.left) : (u.right = 0, s = -o.right), \"number\" == typeof window.devicePixelRatio && devicePixelRatio % 1 == 0 && (s = Math.round(s * devicePixelRatio) / devicePixelRatio, n = Math.round(n * devicePixelRatio) / devicePixelRatio), u[D] = \"translateX(\" + s + \"px) translateY(\" + n + \"px)\", \"msTransform\" !== D && (u[D] += \" translateZ(0)\")) : (t.top ? u.top = o.top + \"px\" : u.bottom = o.bottom + \"px\", t.left ? u.left = o.left + \"px\" : u.right = o.right + \"px\");\n        },\n            g = !0;\n\n        !i(this.options.optimizations) && !1 === this.options.optimizations.allowPositionFixed && (g = !1);\n        var v,\n            b,\n            w = !1;\n        if ((r.page.top || r.page.bottom) && (r.page.left || r.page.right)) u.position = \"absolute\", m(r.page, t.page);else if (g && (r.viewport.top || r.viewport.bottom) && (r.viewport.left || r.viewport.right)) u.position = \"fixed\", m(r.viewport, t.viewport);else if (!i(r.offset) && r.offset.top && r.offset.left) {\n          u.position = \"absolute\";\n          var y = this.cache(\"target-offsetparent\", function () {\n            return F(e.target);\n          });\n          F(this.element) !== y && l(function () {\n            e.element.parentNode.removeChild(e.element), y.appendChild(e.element);\n          }), m(r.offset, t.offset), w = !0;\n        } else u.position = \"absolute\", m({\n          top: !0,\n          left: !0\n        }, t.page);\n        if (!w) if (this.options.bodyElement) this.element.parentNode !== this.options.bodyElement && this.options.bodyElement.appendChild(this.element);else {\n          for (var E = !0, O = this.element.parentNode; O && 1 === O.nodeType && \"BODY\" !== O.tagName && (b = void 0, ((b = (v = O).ownerDocument).fullscreenElement || b.webkitFullscreenElement || b.mozFullScreenElement || b.msFullscreenElement) !== v);) {\n            if (\"static\" !== getComputedStyle(O).position) {\n              E = !1;\n              break;\n            }\n\n            O = O.parentNode;\n          }\n\n          E || (this.element.parentNode.removeChild(this.element), this.element.ownerDocument.body.appendChild(this.element));\n        }\n        var x = {},\n            C = !1;\n\n        for (var T in u) {\n          var P = u[T];\n          this.element.style[T] !== P && (C = !0, x[T] = P);\n        }\n\n        C && l(function () {\n          d(e.element.style, x), e.trigger(\"repositioned\");\n        });\n      }\n    }, g._addClasses = function () {\n      var t = this.options,\n          e = t.classes,\n          o = t.classPrefix;\n      n(this.element, s(\"element\", e, o)), !1 !== this.options.addTargetClasses && n(this.target, s(\"target\", e, o));\n    }, g._removeClasses = function () {\n      var t = this,\n          e = this.options,\n          o = e.classes,\n          i = e.classPrefix;\n      r(this.element, s(\"element\", o, i)), !1 !== this.options.addTargetClasses && r(this.target, s(\"target\", o, i)), this.all.forEach(function (e) {\n        t.element.classList.remove(e), t.target.classList.remove(e);\n      });\n    }, m;\n  }(C);\n\n  R.modules = [], L.position = B;\n  var j = d(R, L);\n  return j.modules.push({\n    initialize: function initialize() {\n      var t = this,\n          e = this.options,\n          o = e.classes,\n          i = e.classPrefix;\n      this.markers = {}, [\"target\", \"element\"].forEach(function (e) {\n        var n = document.createElement(\"div\");\n        n.className = s(e + \"-marker\", o, i);\n        var r = document.createElement(\"div\");\n        r.className = s(\"marker-dot\", o, i), n.appendChild(r), t[e].appendChild(n), t.markers[e] = {\n          dot: r,\n          el: n\n        };\n      });\n    },\n    position: function position(t) {\n      var e = {\n        element: t.manualOffset,\n        target: t.manualTargetOffset\n      };\n\n      for (var i in e) {\n        var n = e[i];\n\n        for (var s in n) {\n          var r,\n              a = n[s];\n          (!o(a) || -1 === a.indexOf(\"%\") && -1 === a.indexOf(\"px\")) && (a += \"px\"), this.markers[i] && (null == (r = this.markers[i].dot) ? void 0 : r.style[s]) !== a && (this.markers[i].dot.style[s] = a);\n        }\n      }\n\n      return !0;\n    }\n  }), j;\n});","map":null,"metadata":{},"sourceType":"module"}